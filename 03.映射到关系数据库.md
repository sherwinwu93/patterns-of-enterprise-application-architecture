### 第3章 映射到关系数据库
数据源层的作用是与应用需要的基础设施的不同部分进行通信.问题主要是和数据库的会话.

关系数据库之所以取得成功,最重要的原因之一就是SQL的存在,它是数据库通信标准语言,核心语法通俗易懂.

#### 3.1 架构模式
架构模式: 它要解决的问题是驱动领域逻辑访问数据库的方式.

许多应用程序开发者不能充分理解SQL,不能很好地构造有效的查询语句和命令.

基于这些原因,把SQL访问从领域逻辑中分离出来,并把它放到独立的类中,实在是明智之举.有一种方法能很好地组织这些类:让它们以数据库中的
表结构为基础,这样,每个数据库表对应一个类.这些类为数据表建立了一个入口.

使用入口的方法主要有两种.最显而易见的是为查询语句返回的每一行产生一个它的实例.这种行数据入口就像是用面向对象的方式来看待数据.

即使简单的应用程序,也倾向于使用一种入口模式,清晰的SQL和领域逻辑分离是相当有益的.

表数据入口与记录集非常匹配,这使得它们称为使用表模块的当然选择,它也是一个组织存储过程的模式.许多设计者都喜欢通过存储过程来完成所
有的数据库访问,而不是直接使用SQL语句.在这种情况下,可以把存储过程的集合看成是为一个表定义的表数据入口.

在简单应用中,领域模型是一种和数据库结构相当一致的简单结构,对应每个数据库表都有一个领域类.这种领域对象的业务逻辑复杂度通常适中.
在这种情况下,有必要让每个领域对象负责数据库的存取过程,这也就是活动记录.从另一个角度来考虑活动记录,就是从行数据入口开始,然后把领
域逻辑加入到类中,特别是在从多个事务脚本中发现了重复代码的时候.

在这种情况下,入口增加的间接性提供的价值不大.随着领域逻辑变得更加复杂,它就慢慢转变成一个大的领域模型,简单的活动记录开始不能满足
要求了.领域类和表的一对一匹配也开始随着把领域逻辑放入更小的类而失效.关系数据库无法处理继承,因此使用策略模式和其他轻巧的面向对象
模式非常困难.随着领域逻辑日益活跃,你回希望不用访问数据库就能随时测试它.

所有这些都迫使你随着领域模型的增大而采用间接的方式.在这种情况下,入口可以解决一些问题,但它仍然将数据库方案和领域模型耦合在一起.
结果就会有一些从入口域到领域对象域的转换,这种转换回使得领域对象变得复杂.

一种更好的办法是把领域模型和数据库完全独立,可以让间接层完成领域对象和数据库表之间的映射.这个数据映射器处理数据库和领域模型之间所
有的存取操作,并且允许双方都能独立变化.这是数据库映射架构种最复杂的架构,但它的好处是把两个层完全独立了.

不推荐把入口用作领域模型的首选持久化机制.如果领域逻辑非常简单并且类和表非常一致,使用活动记录就足够了.如果领域逻辑比较复杂,数据
映射才是需要的.

这些模式并不是完全不能兼容的.但是有必要从这些模式种选择一个,而不要把它们混合在一起,凌乱不堪.

对于视图和查询语句来说,更新容易带来麻烦,因为不能直接对一个视图进行更新,必须去更新这个视图所对应的基础数据表.在这种情况下,实现更
新逻辑的首选方法是把视图/查询用一个合适的模式进行封装,它将使视图的使用变得更加简单可靠.

这样使用视图和查询的问题之一是:对于那些不知道视图如何组成的开发人员来说,可能会带来一些意想不到的不一致性.这些开发人员可能会对两
个不同的结构执行更新,而这两个更新操作可能更新同一个基础表,这样,第二次操作就会重写第一次的操作结果.当然,如果更新逻辑做了必要的确
认工作,就不会出现这样的不一致,但是这样做还是会让开发人员不好理解.

下面介绍用最简单的方法来持久化哪怕是最复杂的领域模型.在对象技术出现的早期,许多人意识到在对象和关系之间有一个"阻抗不匹配"的问题,
因此随之掀起了一股面向对象数据库的研究热潮,从本质上来说,面向对象数据库是将面向对象的理论体系带到了磁盘存储领域.使用面向对象数据
库时,无需担心映射的问题.你可以使用由许多相互关联的对象组成的巨大结构,用数据库来决定何时存取对象.你还可以通过事务将更新操作分组,
或支持数据存储的共享.对于程序员来说,这就好像时一个由磁盘存储器支持的无限事务性内存.

面向对象数据库的主要好处在于它们能提高生成率.

然后,大多数项目并不适用面向对象数据库.主要原因是风险.关系数据库是一种非常容易理解,并且有很多成熟的大型供应商提供长期支持的技术.

#### 3.2 行为问题
谈到O/R映射,人们通常会关注结构方面如何把表和对象联系起来.然而,我发现:实践中最难的部分在于架构和行为方面.

所谓行为问题,就是如何让各种对象从数据库种读取出来以及存到数据库中.乍一看,似乎不是问题.一个客户对象可以拥有加载和保存方法来进行
这项工作.确实,用活动记录,这是一种显而易见的路线.

如果加载了一些对象到内存并且进行了修改,就必须跟踪每个修改过的对象,并保证把它们写回到数据库中.如果仅仅加载了两条记录,这是很容易
的.一旦加载的对象越来越多,这就不再是一件容易的事情,尤其是在创建了某些行的同时,还修改了其他的行的时候,这是由于在修改引用它们的行
之前要获得这些新建行的主键.而且这个问题虽然小,但不容易解决.

因为要读取对象并修改它们,所以就必须保证正在使用的数据库状态的一致性.如果读取了某些对象,重要的是要保证读取必须是独占的,也就是说,
没有其他进程在读取的同时修改这些对象.否则,就可能在对象中得到不一致或无效的数据.这就是同步问题,一个非常棘手的问题.

有一种专门解决上述问题的模式就是工作单元.工作单元会跟踪所有从数据库中读取的对象以及所有以任何形式修改过的对象.它同样负责将更新
提交到数据库.应用程序的编程人员将工作交托给工作单元,而不是直接调用明确的保存方法.工作单元排列好对数据库的操作顺序,把所有复杂的
提交处理放在一起.当与数据库的交互动作比较复杂的时候,工作单元是一个必要的模式.

可以这样理解工作单元,它是一个对象,充当数据库映射的控制器.在没有工作单元的情况下,一般都是由领域层充当控制器,决定何时读写数据库.
工作单元就是来源于把数据库映射控制器的行为分解到它自己的对象中.

加载对象时,必须小心避免把同一个对象加载两次,否则,在内存中就有两个对象和同一个数据库行对应.对它们都进行更新就会乱套了.为了解决这
个问题,可以在标识映射里记录读取的每一行.每次读入数据时,必须到标识映射里去检查一下是不是已经存在了.如果该数据已经加载,可以返回一
个对它的引用.这样,所有更新操作就可以正确地组织好.还可以得到一些好处,比如可能避免一些数据库调用,因为标识映射就像一个数据库高速缓
存.不过不要忘了,标识映射的主要目的是保持一致性,而不是提高性能.

如果使用了领域模型,就必须合理安排,使得关联的对象一起加载,例如,在读取一个订单对象的同时,把与之相关联的客户对象也一同加载进来.然
而,如果许多对象都是连接在一起的,则读取任何对象都会从数据库中带出大批的对象.为了避免这种低效,必须设法减少带出来的东西.当然,还需
要保持接口以便在以后需要的时候再来取.延迟加载的主要思想是拥有一个对象引用的占位符.可以采用几种方法,但它们的共同点都是拥有被修改
对象的对象引用,它指向的是一个占位符而不是实际的对象.当且仅当想要通过链接访问的时候,才会真的取数据库中读取实际的对象.适当使用延
迟加载能使得每次数据调用取得刚好够用的数据.

#### 3.3 读取数据
读取数据的时候,可以把读取数据的方法看作一个查找器,它通过一个方法结构的接口来隐藏SQL查询语句.因此,可以使用诸如find(id)或者find-
ForCustomer(customer)这样的方法.当然,如果查询语句由23个不同的子句,那么这些方法会非常低效,不过谢天谢地,这种情况非常少见.

在什么地方放置查找器方法是由使用的接口模式决定的.如果数据库交互类是基于表的,也就是说对于数据中的每个表都有一个类的实例与之对应,
那么就能把插入和更新操作也捆绑在查找器方法中.如果交互类是基于数据行的,也就是说对于数据库中的每一行都有一个类的实例与之对应,这种
情况就不行了.

用基于行的类可以使查找变成静态操作,但是这样就会使得数据库操作不可替代.这也就意味着不能通过服务桩在测试的时候调换数据库.为了避免
这个问题,最好是创建独立的查找器对象.每一个查找器类都有很多封装了SQL语句的方法.当执行查询操作的时候,查找器对象返回一个适当的基于
行的对象集合.

使用查找器方法时要注意的是:这些查找器方法工作在数据库状态下而不是对象状态下.如果发出一个对数据库的查询语句找到一个俱乐部内所有
的人,那么任何你在内存中加入到俱乐部的人都不会返回.解决这类问题的办法是在一开始就进行查询.

读取数据的时候,性能问题可能会变得比较突出.这就导致了几条经验法则.

尽量一次都会多行.实际上,最好不要为了得到多行而在同一个表上重复查询.得到的数据多往往比得到的数据少好(尽管你必须要注意通过悲观并
发空置一次锁定了太多的行).因此,考虑这种情况,需要得到50个人,这50个人可以通过领域模型中的主键确定,但是你只能构造一个查询得到200
个人,在这200人当中必须使用更多的逻辑判断来取得想要的50个人.不过,通过一次查询得到一些冗余的行要比进行50次独立的查询好.

另一个避免多词进入数据库的方法是使用联接(Join).这样就可以通过一次查询返回多个表.得到的记录集可能看起来比较奇怪,但是确实能加快
查询速度.在这种情况下,可以建立一个入口来得到相互联接的表数据,或者通过一个数据映射器用一次调用加载多个领域对象.

然而,如果正在使用联接操作.记住数据库必须优化在一次查询中处理3~4个连接.一旦超出这个范围,将会带来性能损失,尽管可以通过缓存视图来
重新装入大部分数据.

数据库中可以进行很多优化.这些优化包括把相互关联的数据组织到一起,小心地使用索引,以及数据库的缓存功能.作为一个好的DBA,需要好好掌
握这些内容.

在所有的情况下,应该根据你具体的数据库和数据来对应用程序进行分析.一些通用的规则可以作为知道,但是你的特定环境往往由它们自己的变
化.数据库系统和应用服务器经常由复杂的缓冲机制,很难预测具体的应用程序会发生什么情况.对于每个我用过的经验法则,我都听说过令人惊讶
的异常情况,所以用额外的时间进行性能剖析和调整.

#### 3.4 结构映射模式

当人们谈到对象-关系映射的时候,他们多半说的是结构映射模式,在内存对象与数据库表的映射中会用到它们.这些模式通常与表数据入口并不相
关,但是可以在使用行数据入口或者活动记录的时候使用其中一些模式.在使用数据映射器的时候,所有模式可能都会需要.

##### 3.4.1 关系的映射
这里的关键问题在于对象和关系处理连接的方法不同.这会带来两个问题.首先,表现方法不同.对象是通过在运行时(内存管理环境或内存地址)中
保存引用的方式来处理连接的.其次,对象可以很容易通过集合来表示多个引用,而规范化则要求所有的关系连接都必须是单值的.这就导致对象和
表之间的数据结构颠倒了.一个订单对象自然拥有一个订单项的集合,而这些订单项不需要持有订单对象的引用.然而,表结构中的各订单项必须包
含一个到订单的外键,因为订单不能有一个多值域.

解决这种表现问题的方法是:通过对象中的一个标识域来保持每个对象的关系特性,并且通过查找这些值来保持对象引用和关系键之间的相互映射.
这是一个乏味的过程,但是一旦理解了基本原理后却并不困难.从硬盘中读取数据的时候,使用标识映射作为从关系键到对象的查找表.每次使用表
中的外键,都用外键映射来得到合适的对象间引用.如果标识映射中没有该键值,就需要到数据库中读取它或者使用延迟加载.每次存储对象时,就可
以用正确的键值把它存在行中,用目标对象的ID域替换任意的对象间引用.

图3-5

在这个基础上,集合的处理需要更复杂的外键映射版本.如果对象包含一个集合,则必须构造一个新的查询来找到所有与源对象的ID相关的行(也可
以通过延迟加载来避免查询).创建每个返回的对象并加入到集合中.对这个集合的保存包括:保存其中每一个对象,并且保证它拥有一个到源对象的
外键.这样非常混乱,尤其是当要检测对象加入或者移出这个集合的时候.当你熟悉了之后,就会发现这是重复性问题,这也是为什么某些基于元数据
的方法会明显导致系统规模更大的原因.如果集合中的对象不在集合拥有者范围之外使用,就可以使用依赖映射来简化映射.

图3-6

多对多的关系情况不同,这时在两边都存在集合.例如,一个人有很多种技能,并且对每种技能都要知道哪些人在使用它.关系数据库不能直接解决
这种问题,因此需要使用关联表映射来创建一个新的关系表,仅仅是为了解决多对多的关联问题.

图3-7

使用集合的时候,通常需要依赖集合中的排序.在面向对象语言中,通常使用数组或者列表这样的有序集合--实际上,这还可以简化测试的难度.然
而,在保存到关系数据库中的时候想要维持一个绝对有序的集合是非常困难的.因此,有必要考虑使用无序集来存储集合.另一种方法是无论何时进
行集合查询都要按照某种分类顺序,尽管有时候这样做代价很高.

在某些情况下,引用完整性会使得更新更加复杂.现代的系统允许把引用完整性查询延迟到交互结束的时候进行.如果有这个能力,没有道理不使用
它.否则,数据库会在每次写操作的时候进行检查.在这种情况下,将不得不注意按照正确的顺序进行更新操作.

标识域用来把对象间引用变为外键,但并不是所有的对象关系都需要用这种方法持久化.一些小的值对象(比如日期范围和钱)显然不应该描述成数
据库中它们自己的表.取而代之的是,取出值对象中所有的域,并以嵌入值方式把它们嵌入到关联对象中.由于值对象含有值得语义,可以在每次执行
读操作的时候创建它们,而无需担心标识映射的问题.把它们写道外面也非常任意,仅仅需要解除对象引用,并且把它的域写到它自己的表中即可.

还可以在更大规模上做类似工作,此时,可以通过序列化LOB将一组对象存储为表中的单个列.LOB代表大对象,它可以是二进制的,也可以是文本的.
将一组对象序列化为XML文档,对于层次化对象结构式显然可以采取的方法.这样就可以通过一次读取获得一整串互相关联的小对象.通常,数据库
对于小的高层互联对象执行起来很低效,因为需要花费大量时间来进行许多很小的数据库调用.层次结构(诸如组织结构图表和材料账单),都能通
过序列化LOB节省大量的数据库开销.

问题是SQL并不知道发生了什么事,这样就不能对应数据结构来建立可移植的查询.在这里,XML将再次发挥功效,它允许在SQl调用之中嵌入XPath查
询表达式,尽管嵌入方法现在还远没有标准化.因此,在不想对存储结构的内部进行查询的时候,最好使用序列化LOB.

通常,序列化LOB对于用来组成应用程序部分的相对独立群而言是最好的.但如果过多使用它,最终会把数据库弄得和事务文件系统差不多.

##### 3.4.2 继承
前文中所述的层次,大多是组合层次.比如传统的关系系统难以处理的部件树.还有另外一种也会使得关系系统头疼的层次:通过继承关系相互连接
的类层次.因为在SQL里面没有用于继承的标准方法,所以我们就必须再用到一个映射.对于任何继承结构,一般都有三种选择.可以为一个层次中的
所有类建立一个表,即单表继承(图3-8);也可以为每个具体类建立一个表,即具体表继承(图3-9);或者为这个层次中每一个类建立一个表:类表继
承(图3-10).

图3-8, 3-9

在数据结构复制和访问速度之间必须进行权衡.类表继承是类和表之间最简单的关系,但是它需要多个连接(join)操作来载入一个对象.这样通常
损失了性能.具体表继承避免了连接操作,允许从一个表中取得一个对象,但是改变起来比较困难.对超类的任何改变都不得不改变所有的表(还有
映射代码).改变层次结构自身会带来更大的改变.缺乏超类表也能使主键管理十分可拍,引用完整性也有问题,尽管它能减少超类表中的锁争夺.而
在某些数据库中,单表继承最大的弊端是浪费了空间,因为每一行都必须为每种可能的子类保存一些列,这就导致很多空列.然而,许多数据库都能很
好地压缩浪费的表空间.单表继承的另一个问题在于它的大小将称为访问的瓶颈.它最大的好处是把所有的内容都放到一起,这样修改起来很容易并
且避免了连接操作.

图 3-10

我更倾向于单表继承.单表继承把所有的超类和接口放到一个大表中,类表继承为每个接口和超类建立一个独立的表,具体表继承在每一个具体表中
包含了所有的接口和超类.

#### 3.5 建立映射
映射到关系数据库的时候,一般会遇到三种情况:
1. 自己选择数据库方案.
2. 不得不映射到一个现有数据库方案,这个方案不能改变.
3. 不得不映射到一个现有数据库方案,这个方案是可以考虑改变的.

最简单的情况是自己选择数据库方案,并且不用迁就领域逻辑的复杂性,最终得到的结果是一个事务脚本或者表模块设计.在这种情况下,可以使用
经典的数据库设计技术围绕数据来设计表.使用行数据入口或者表数据入口来把SQL从领域逻辑中剔除.

如果在使用领域模型,应该小心那种看上去像数据库设计的设计.在这种情况下,建立领域模型时不用理会数据库,这样可以简化领域逻辑.把数据库
设计看作一种持久化对象数据的办法.数据映射器非常灵活,当然也带来了复杂性.如果数据库设计和领域模型同构有意义,可以考虑使用活动记录
来代替.

尽管首先建立模型是一种合理的方法,但这个建议仅仅适用于短的迭代周期内.花费6个月的时间建立一个没有数据库的领域模型,并且决定一旦完
成就持久化它,这是一件非常冒险的事情.危险在于,设计结果会因为迫切的性能问题而需要进行很多重构来修改.相反,应该为每一次迭代建造数据
库,时间上不要超过6周并且适当地更短一些.这样就能更快和更持续地得到关于数据库交互实际上如何工作的反馈.针对特定任务,都应该首先考虑
领域模型,但是这样做的时候,需要在数据库中集成领域模型的每一部分.

当已经存在一个数据库方案的时候,选择很相似,但过程却有点不同.对于简单的领域逻辑,可以建造行数据入口或者表数据入口来模拟数据库,并在
此之上构建领域逻辑.如果领域逻辑更复杂一些,将需要一个领域模型,而这个模型很可能和数据库设计不匹配.因此,应该逐步建立领域模型并包括
数据映射器,把数据保存到现有的数据库中.

##### 双向映射
可能有多个数据库保存相同的数据,只是由于某种复制和粘贴的重用会导致在数据库方案上的一些细微区别.另一种可能是使用不同的存储机制,有
时时数据库,有时是消息.也可能希望把类似的数据通常从XML消息、CICS事务和关系表中国抽取出来.

最简单的选择是建立多个映射层,每个数据源一个.然而,如果数据非常类似的话,就会导致过多的复制.在这种情况下,可以考虑两步映射策略.第一
步把数据从内存方案中转化到逻辑数据存储方案.设计逻辑数据存储方案是用来最大化数据源格式中的相似之处.第二步映射从逻辑数据存储方案
到实际物理存储方案.第二步包含区别.

当有许多共同点时,额外的步骤仅仅补偿它们自身,因此你应该在有相似但又有十分头疼的不同的物理数据存储时使用它.把从逻辑数据存储到物理
数据存储的映射看成是一个入口,并且使用任何映射技术从应用程序逻辑映射到逻辑数据存储.

#### 3.6 使用元数据
利用简单和重复性映射,这样会导致代码简单和重复,而重复代码是设计上有问题的一个标志.可以通过委托和继承分解出通用行为,但还有一种更
成熟的方法是使用元数据映射.

元数据映射基于把映射浓缩到元数据文件的方法.元数据文件详细描述数据库中的列如何映射到对象的域.这里的关键在于:一旦有了元数据,就可
以通过代码生成或者反射编程来避免重复性代码.

使用元数据使我们可以用少量元数据表达很多含义.一行元数据可以像这些传递某些信息:
<field name="customer" targetClass="Customer" dbColumn="custID" targetTable="customers" lowerBound="1" upperBound="1"
setter="loadCustomer/>

从这些信息可以定义读写代码,自动产生特别的连接操作,完成所有的SQL,加强关系的多样性,甚至可以做许多奇特的事情,比如在引用完整性存在
的情况下计算写顺序等.这也就是为什么商业O/R映射工具倾向于使用元数据的原因.

当使用<元数据映射>的时候,有必要构造对内存对象的查询.一个查询对象允许根据内存对象和数据来构造查询,在这种方式下,开发者不需要知道
SQL或关系数据库方案的细节.查询对象可以使用元数据映射把基于对象域的表达式翻译到对应的SQL.

一旦使用这种方法就可以建立一个资源库,它能在很大程度上从视图隐藏数据.任何到数据库的查询都可以做成<资源库>基础上的查询对象,并且开
发者不用分辨对象是从内存还是从数据库中找回.资源库在有丰富领域模型的系统下工作良好.

你一旦熟悉了这些模式,并且能用它们手写出自己的应用,就能领会到如何使用元数据来使问题更简单.

#### 3.7 数据库连接
大多数数据库接口依赖于某些数据库连接对象,它们就好像应用程序代码和数据库之间的连接桥梁.通常,一个连接必须在能执行针对数据库的命令
之前就打开.实际上,经常需要一个显式连接来建立和执行命令.在命令的整个执行过程中,该连接必须是打开的.查询的结果将返回一个<记录集>.
某些接口提供无连接的<记录集>,这些记录集在连接关闭之后还能继续使用.其他的接口只提供连接的记录集,这意味着当记录集正在使用的时候必
须一直打开.如果正在一个事务中运行,经常会把事务绑定在特定的连接中,当它运行的时候这个连接也必须一直打开.

在很多环境中,建立连接的开销相当大,这就需要建立一个连接池.在这种情况下,开发者向连接池请求一个连接并在完成以后释放,而无需即时创建
和关闭.现在多数平台都会提供连接池,所以很少需要自己来实现连接池.如果必须自己实现连接池,首先就要检查连接池是不是真的能提高性能.越
来越多的环境使我们可以更快地创建新的连接,因此不需要缓冲池.

提供连接池的环境经常把连接池放在一个类似创建新连接的接口后面.用这种方法,无需知道得到的时一个新创建连接还是从连接池里面分配的.那
样很好,因为是否选择连接池被很好地封装起来.类似地,关闭一个连接可能并没有真关闭它,而只是把它交还给连接池以便别人可以使用.在这里,
我说的打开和关闭,也可以替换为从连接池获取和释放.

无论创建连接的代价是高还是低,连接都必须好好管理.因为它们是珍贵的资源,必须在使用完毕时立刻关闭.还有,如果正在进行一次事务,通常需
要保证: 在这次特定的事务中,每一个命令都是从同一个连接发出的.

最常见的建议就是用一个到连接池或者连接管理器的调用,显式得到一个连接,并且通过它来执行数据库命令.一旦执行完了,立刻把它关闭.这个建
议带来两个问题:首先,保证在任何需要的地方都能得到一个连接;其次,保证不会再最后忘记关闭它.

