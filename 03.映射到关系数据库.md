### 第3章 映射到关系数据库
数据源层的作用是与应用需要的基础设施的不同部分进行通信.问题主要是和数据库的会话.

关系数据库之所以取得成功,最重要的原因之一就是SQL的存在,它是数据库通信标准语言,核心语法通俗易懂.

#### 3.1 架构模式
架构模式: 它要解决的问题是驱动领域逻辑访问数据库的方式.

许多应用程序开发者不能充分理解SQL,不能很好地构造有效的查询语句和命令.

基于这些原因,把SQL访问从领域逻辑中分离出来,并把它放到独立的类中,实在是明智之举.有一种方法能很好地组织这些类:让它们以数据库中的
表结构为基础,这样,每个数据库表对应一个类.这些类为数据表建立了一个入口.

使用入口的方法主要有两种.最显而易见的是为查询语句返回的每一行产生一个它的实例.这种行数据入口就像是用面向对象的方式来看待数据.

即使简单的应用程序,也倾向于使用一种入口模式,清晰的SQL和领域逻辑分离是相当有益的.

表数据入口与记录集非常匹配,这使得它们称为使用表模块的当然选择,它也是一个组织存储过程的模式.许多设计者都喜欢通过存储过程来完成所
有的数据库访问,而不是直接使用SQL语句.在这种情况下,可以把存储过程的集合看成是为一个表定义的表数据入口.

在简单应用中,领域模型是一种和数据库结构相当一致的简单结构,对应每个数据库表都有一个领域类.这种领域对象的业务逻辑复杂度通常适中.
在这种情况下,有必要让每个领域对象负责数据库的存取过程,这也就是活动记录.从另一个角度来考虑活动记录,就是从行数据入口开始,然后把领
域逻辑加入到类中,特别是在从多个事务脚本中发现了重复代码的时候.

在这种情况下,入口增加的间接性提供的价值不大.随着领域逻辑变得更加复杂,它就慢慢转变成一个大的领域模型,简单的活动记录开始不能满足
要求了.领域类和表的一对一匹配也开始随着把领域逻辑放入更小的类而失效.关系数据库无法处理继承,因此使用策略模式和其他轻巧的面向对象
模式非常困难.随着领域逻辑日益活跃,你回希望不用访问数据库就能随时测试它.

所有这些都迫使你随着领域模型的增大而采用间接的方式.在这种情况下,入口可以解决一些问题,但它仍然将数据库方案和领域模型耦合在一起.
结果就会有一些从入口域到领域对象域的转换,这种转换回使得领域对象变得复杂.

一种更好的办法是把领域模型和数据库完全独立,可以让间接层完成领域对象和数据库表之间的映射.这个数据映射器处理数据库和领域模型之间所
有的存取操作,并且允许双方都能独立变化.这是数据库映射架构种最复杂的架构,但它的好处是把两个层完全独立了.

不推荐把入口用作领域模型的首选持久化机制.如果领域逻辑非常简单并且类和表非常一致,使用活动记录就足够了.如果领域逻辑比较复杂,数据
映射才是需要的.

这些模式并不是完全不能兼容的.但是有必要从这些模式种选择一个,而不要把它们混合在一起,凌乱不堪.

对于视图和查询语句来说,更新容易带来麻烦,因为不能直接对一个视图进行更新,必须去更新这个视图所对应的基础数据表.在这种情况下,实现更
新逻辑的首选方法是把视图/查询用一个合适的模式进行封装,它将使视图的使用变得更加简单可靠.

这样使用视图和查询的问题之一是:对于那些不知道视图如何组成的开发人员来说,可能会带来一些意想不到的不一致性.这些开发人员可能会对两
个不同的结构执行更新,而这两个更新操作可能更新同一个基础表,这样,第二次操作就会重写第一次的操作结果.当然,如果更新逻辑做了必要的确
认工作,就不会出现这样的不一致,但是这样做还是会让开发人员不好理解.

下面介绍用最简单的方法来持久化哪怕是最复杂的领域模型.在对象技术出现的早期,许多人意识到在对象和关系之间有一个"阻抗不匹配"的问题,
因此随之掀起了一股面向对象数据库的研究热潮,从本质上来说,面向对象数据库是将面向对象的理论体系带到了磁盘存储领域.使用面向对象数据
库时,无需担心映射的问题.你可以使用由许多相互关联的对象组成的巨大结构,用数据库来决定何时存取对象.你还可以通过事务将更新操作分组,
或支持数据存储的共享.对于程序员来说,这就好像时一个由磁盘存储器支持的无限事务性内存.

面向对象数据库的主要好处在于它们能提高生成率.

然后,大多数项目并不适用面向对象数据库.主要原因是风险.关系数据库是一种非常容易理解,并且有很多成熟的大型供应商提供长期支持的技术.

#### 3.2 行为问题
谈到O/R映射,人们通常会关注结构方面如何把表和对象联系起来.然而,我发现:实践中最难的部分在于架构和行为方面.

所谓行为问题,就是如何让各种对象从数据库种读取出来以及存到数据库中.乍一看,似乎不是问题.一个客户对象可以拥有加载和保存方法来进行
这项工作.确实,用活动记录,这是一种显而易见的路线.

如果加载了一些对象到内存并且进行了修改,就必须跟踪每个修改过的对象,并保证把它们写回到数据库中.如果仅仅加载了两条记录,这是很容易
的.一旦加载的对象越来越多,这就不再是一件容易的事情,尤其是在创建了某些行的同时,还修改了其他的行的时候,这是由于在修改引用它们的行
之前要获得这些新建行的主键.而且这个问题虽然小,但不容易解决.

因为要读取对象并修改它们,所以就必须保证正在使用的数据库状态的一致性.如果读取了某些对象,重要的是要保证读取必须是独占的,也就是说,
没有其他进程在读取的同时修改这些对象.否则,就可能在对象中得到不一致或无效的数据.这就是同步问题,一个非常棘手的问题.

有一种专门解决上述问题的模式就是工作单元.工作单元会跟踪所有从数据库中读取的对象以及所有以任何形式修改过的对象.它同样负责将更新
提交到数据库.应用程序的编程人员将工作交托给工作单元,而不是直接调用明确的保存方法.工作单元排列好对数据库的操作顺序,把所有复杂的
提交处理放在一起.当与数据库的交互动作比较复杂的时候,工作单元是一个必要的模式.

可以这样理解工作单元,它是一个对象,充当数据库映射的控制器.在没有工作单元的情况下,一般都是由领域层充当控制器,决定何时读写数据库.
工作单元就是来源于把数据库映射控制器的行为分解到它自己的对象中.

加载对象时,必须小心避免把同一个对象加载两次,否则,在内存中就有两个对象和同一个数据库行对应.对它们都进行更新就会乱套了.为了解决这
个问题,可以在标识映射里记录读取的每一行.每次读入数据时,必须到标识映射里去检查一下是不是已经存在了.如果该数据已经加载,可以返回一
个对它的引用.这样,所有更新操作就可以正确地组织好.还可以得到一些好处,比如可能避免一些数据库调用,因为标识映射就像一个数据库高速缓
存.不过不要忘了,标识映射的主要目的是保持一致性,而不是提高性能.

如果使用了领域模型,就必须合理安排,使得关联的对象一起加载,例如,在读取一个订单对象的同时,把与之相关联的客户对象也一同加载进来.然
而,如果许多对象都是连接在一起的,则读取任何对象都会从数据库中带出大批的对象.为了避免这种低效,必须设法减少带出来的东西.当然